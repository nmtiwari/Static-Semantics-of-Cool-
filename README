README file for Programming Assignment 4 
======================================================

Your directory should now contain the following files:

 Makefile		
 README
 ast-lex.cc		
 ast-parse.cc		
 bad.cl
 cgen			
 cool-tree.cc		
 cool-tree.h
 cool-tree.handcode.h
 dumptype.cc		
 good.cl
 handle_flags.cc	
 mycoolc		
 mysemant		
 semant-phase.cc	
 semant.cc
 semant.h
 stringtab.cc		
 symtab_example.cc	
 tree.cc		
 utilities.cc		

	The README contains this info. Part of the assignment is to fill
	the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and
	why your test cases are adequate. It is part of the assignment
	to clearly and concisely explain things in text as well as to
	comment your code.  Just edit this file.

	good.cl and bad.cl test a few features of the semantic checker.
	You should add tests to ensure that good.cl exercises as many
	legal semantic combinations as possible and that bad.cl
	exercises as many kinds of semantic errors as possible.

	semant.h contains declarations and definitions for the semantic
	analyzer.  Place class definitions for the structures you will
	use here.

	cool-tree.aps contains the definitions for the tree language
	which you use to construct the abstract syntax tree (AST).
	From this file, cool-tree.h and cool-tree.cc are automatically 
        generated by a utility that compiles the specification into
        C++ functions for producing and consuming the tree nodes.
        This file is provided for your reference.  DO NOT MODIFY.

        tree.{cc|h} contain definitions used by the tree package.  DO
        NOT MODIFY.

        cool-tree.h, and cool-tree.handcode.h specify and give an
        implementation of Cool ASTs (see the README for PA3 and the
        "Cool Tour").  In this assignment, you will need to add
        functions to the AST classes to store, fetch, and compute
        information about the AST.  Note that cool-tree.handcode.h
        differs slightly from the file supplied for PA3.

   	You should NOT remove any definitions that are already present
	in cool-tree.h and cool-tree.handcode.h.  These functions and
	data members are required for the system to function properly.

        You should add any fields and methods to the classes you need to 
	perform semantic analysis.  You	will need to add, for example, 
	methods which traverse the expressions of the tree and implement 
	the type-checking rules.

	cool-tree.cc contains definitions of the provided methods,
	and instantiations of the template for the list handling functions.
	You should not modify this file, but place definitions of all
	methods you add to cool-tree.h or cool-tree.handcode.h in semant.cc.
	DO NOT MODIFY cool-tree.cc

	semant.cc is the file in which you should write your semantic
	analyzer.  The main() procedure calls the method `semant'
	on `ast_root', the root of the abstract syntax tree generated by
	the parser.  There are methods supplied that you should use to report 
	errors. You are relatively free in how you decide to structure the 
	semantic checker, but don't modify the error printing routines.

	ast-lex.cc and ast-parse.cc implement a lexer and a parser for
	reading text representation of ASTs from console in the format
	produced by the parser phase. DO NOT MODIFY.

	semant-phase.cc contains a test driver for semantic analysis.
	The main program reads an AST in text form from standard input,
	parses it, and then produces a type-annotated AST on standard
	output.  The script mycoolc can pass any of the standard flags
	to the semantic analyzer as well; for this assignment, -s
	(semantic analysis debug) may be useful as it sets a global
	variable semant_debug to true (1).  If you want your semantic
	checker to print debug information when the option is set, write
	your debug code in the following format:

	      if (semant_debug)
	      {
		...
	      }

	semant_debug is provided as a convenience. You don't need to use
	the debugging flags if you don't want to. DON'T MODIFY
	semant-phase.cc

	symtab.h contains a symbol table implementation. Read the
	comments in the file, the "Cool Tour", and look at the example
	in symtab_example.cc.  You are not required to use this code,
	but you may find it useful. DO NOT MODIFY.

Instructions
------------

	To compile the example use of the symbol table, type

	% gmake symtab_example
        % ./symtab_example

	To compile your semantic analyzer program type:

	% gmake semant

	To test your semantic checker, type:

        % ./mysemant good.cl

	mysemant is a version of mycoolc that omits code generation.
	mysemant parses all the cool files given on the command line and
	builds a single abstract syntax tree containing all class
	definitions appearing in the input files. Your semantic checker
	is then called on this abstract syntax tree.  If there are no
	errors, the program produces a type-annotated abstract syntax
	tree as output.

	To run your checker on the files good.cl and bad.cl type:

	% gmake dotest

	If you think your semantic checker is correct and behaves like
	the one we wrote, you can try to run mycoolc using your checker,
	your parser and also your lexical analyzer if you choose (see
	below for instructions).  Remember if your lexer, parser or
	checker behaves in an unexpected manner, you may get errors
	anywhere.

	% gmake clean

	when you switch from one type of machine to the other.
	If at some point you get weird errors from the linker,	
	you probably forgot this step.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA4
----------------

----------------------------------
Team Members:                    |
1. Nitin Mukesh Tiwari           |
2. Syeda Khairunnesa Samantha    |
3. Eric Lin                      |
----------------------------------

Write-up
---------

We have added all the types required for type checking semantics of the language in 
cool-tree.h. A snapshot of the types is
enum TreeType {
    ClassType,
    // Feature
    MethodType,
    AttrType,
    // Formal
    FormalType,
    // Expression
    AssignType,
    StaticDispatchType,
    DispatchType,
    CondType,
    LoopType,
    CaseType,
    BlockType,
    LetType,
    PlusType,
    SubType,
    MulType,
    DivideType,
    NegType,
    LtType,
    EqType,
    LeqType,
    CompType,
    IntType,
    BoolType,
    StringType,
    NewType,
    IsVoidType,
    NoExpressionType,
    ObjectType,
    // Branch
    BranchNameType,
    BranchTypeType
};

After that we have added the methods for enforcing type check for all the types one by one in 
semant.cc.
Each type checking method is different in itself because of the elements type checked by the 
method. For example in case of type checking of the classes only we need to make sure that classes do have 
type checking semantics of parent classes (making sure that all parent classes are defined and they
are not of primitive types). Next important thing to make sure is that all the attributes of the classes
are perfectly defined and they also succeed in their respective type checks. 
Hence it is necessary to keep each element type safe throughout the code. Following are brief comments about all
the methods that we have introduced in this system.



semantics of methods:
/*
    Semantics of the method involves type checking for return type, argument, expressions and 
    then all statements (body) of the method. Following method is used for type checking that
    method is defined with correct return type, return type does exist. Moreover no field is defined multiple
    times in the same method.
*/

/*
    Overloading and overriding are two main concepts of the OOP. In this part of the 
    type check semantics takes care of the number of arguments, their type and return type
    in overloading and overriding the methods.This also takes care of scope rules.
*/

/*
    Methods can not have multiple defined arguments and they can not even have self_type as argument of the
    function. We need to take care that all methods follow this rule of type semantics before we go in 
    code generation phase of compilation.
*/

semantics of class: 
	/*
  This method is used to check the type semantics of the classes defined in the 
  cool program. In this section we check for the inheritance of the class. We make 
  sure that class does not inherit any primitive type or undefined class. We actually check
  the symbol table for the availablity of the parent class. If parent class is not defined in the
  symbol table the inheritance can not be of legal type. Furthermore we also need to make sure that a class
  does not inherits itself. 
*/

semantics of class expressions: 
/*
  This method is also used for type checking the semantics of the classes. Here we actually check the type 
  correctness of the attributes of the classes. Attribute checking requires us to check the type correctness of
  all the fields defined in the class along with the methods. 
  Here we traverse the AST in recursive manner to type check all the attributes.
*/
  

  semantics of class attributes: 
/*
  This method is also used for type checking the semantics of the classes. Here we actually check the type 
  correctness of the attributes of the classes. Checks like each attribute is defined only once, there are
  no self type checking and then also that assignment of the attributes are done with same type or subtype. 
*/
  
  parent class attribute checking:
/*
  This method is also used for type checking the semantics of the attributes of the class. Here we actually check the type correctness of the attributes of the parent classes. 
*/
  
/*
    There are multiple expression types in cool and they have different semantics. We have defined a 
    function which takes care of the types checking of all the expression by switch case analysis. Cases of the switch statement involve : 
    AssignType
    StaticDispatchType
    DispatchType
    ObjectType
    IsVoidType
    NewType
    StringType
    BoolType
    IntType
    CompType
    LeqType
    EqType
    LtType
    NegType
    DivideType
    MulType
    SubType
    PlusType
    LetType
    BlockType
    CaseType
    LoopType
    CondType
*/

/* Apart from the above mentioned type checking rules we have coded semantics for the dispatch and other expressions. */


good.cl:
As per our understanding any good working and compilable code of cool programming language can be thought 
of as a candidate of the good.cl. However specifically we have used graph.cl from the examples given in the
cool compiler. Reason for the choice of the graph.cl is 
	it has inheritance
	it has method overloading 
	it has method overriding 
	it has maximum possible expressions

bad.cl
In this file we have added code from working example of graph.cl and then worked on it to cover all the possible
type check semantics error.
Some of the errors covered for example are: 
bad.cl:216: Class Cons was previously defined.
bad.cl:254: Class Main was previously defined.
bad.cl:637: Class Main was previously defined.
bad.cl:330: Class Vertice cannot inherit class SELF_TYPE.
bad.cl:363: Attribute weight is multiply defined in class.
bad.cl:394: MethodisNil is multiply defined.
bad.cl:394: Formal parameter e cannot have type SELF_TYPE.
bad.cl:188: In call of method init, type Book of parameter i does not conform to declared type Int.
bad.cl:188: Inferred return type List of method cons does not conform to declared return type Cons.
bad.cl:254: Dispatch to undefined method cons.
bad.cl:254: Dispatch to undefined method cons.
bad.cl:330: In call of method cons, type Edge of parameter e does not conform to declared type SELF_TYPE.
bad.cl:330: Dispatch to undefined method out_int.
bad.cl:394: Formal parameter e cannot have type SELF_TYPE.
bad.cl:394: In call of method init, type SELF_TYPE of parameter e does not conform to declared type Edge.
bad.cl:394: In call of method cons, type Edge of parameter e does not conform to declared type SELF_TYPE.
bad.cl:501: Inferred return type Bool of method isNil does not conform to declared return type Int.
bad.cl:501: Assignment to undeclared variable car.
bad.cl:501: Type Vertice of assigned expression does not confrom to declared type VList of identifier cdr.
bad.cl:501: Inferred return type SELF_TYPE of method init does not conform to declared return type VList.
bad.cl:501: Undeclared identifier car.
bad.cl:501: Dispatch to undefined method print.
Compilation halted due to static semantic errors.




========================================================================================================================

========================================================================================================================
Notes:
All the changes made in the homework are written in this file and they have also been commented in the
semant.cc file. Implementation of type checker is hard problem and solution of this homework is referred from Internet.
We faced some hard challenges to solve the type checking rules of the method dispatch specifically. 
In particular we referred to github.com to resolve issues in our solution. Major work of the homework is to understand the type checking rule implementation. It is also to understand how recursive traversal of the tree is required for accessing the type information of the involved information.  

